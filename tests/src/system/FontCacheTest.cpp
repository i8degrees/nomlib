#include "gtest/gtest.h"

// GTest helpers
#include "nomlib/tests/common/UnitTest.hpp"

#include <nomlib/graphics.hpp>
#include <nomlib/system.hpp>

namespace nom {

class FontCacheTest: public nom::UnitTest
{
  public:
    FontCacheTest()
    {
      // Enable function call tracing of engine initialization
      // nom::SDL2Logger::set_logging_priority( NOM_LOG_CATEGORY_TRACE_SYSTEM, nom::LogPriority::NOM_LOG_PRIORITY_VERBOSE );

      // Enable initialization status logging
      // nom::SDL2Logger::set_logging_priority( NOM_LOG_CATEGORY_SYSTEM, nom::LogPriority::NOM_LOG_PRIORITY_INFO );

      // Hides non-critical messages that might be generated by functions when
      // running tests. Generally speaking, only tests that explicitly check for
      // invalid conditions should be subject to a desire for hiding the logged
      // messages (for sake of cleanliness).
      // nom::SDL2Logger::set_logging_priority(NOM_LOG_CATEGORY_APPLICATION, NOM_LOG_PRIORITY_CRITICAL);
      nom::SDL2Logger::set_logging_priority(NOM, NOM_LOG_PRIORITY_CRITICAL);
    }

    virtual ~FontCacheTest()
    {
      // ...
    }

    virtual void SetUp() override
    {
      std::string res_file = this->test_case() + ".json";

      ASSERT_TRUE( res_bitmap.load_file(res_file, "bitmap") )
      << "Could not resolve 'bitmap' from the resource path in file: "
      << res_file;

      ASSERT_TRUE( res_truetype.load_file(res_file, "truetype") )
      << "Could not resolve 'truetype' from the resource path in file: "
      << res_file;

      ASSERT_TRUE( res_bm.load_file(res_file, "bm") )
      << "Could not resolve 'bm' from the resource path in file: "
      << res_file;
    }

  protected:
    nom::SearchPath res_bitmap;
    nom::SearchPath res_truetype;
    nom::SearchPath res_bm;
};

TEST_F( FontCacheTest, ResourceCacheAPI )
{
  ResourceCache<Font> fonts_;
  File fp;
  Path p;

  ASSERT_TRUE( fonts_.append_resource( ResourceFile("LiberationSerif", res_truetype.path() + "LiberationSerif-Regular.ttf", ResourceFile::Type::TrueTypeFont) ) );
  ASSERT_TRUE( fonts_.append_resource( ResourceFile("LiberationSerif-Bold", res_truetype.path() + "LiberationSerif-Bold.ttf", ResourceFile::Type::TrueTypeFont) ) );

  ASSERT_TRUE( fonts_.append_resource( ResourceFile("VIII", res_bitmap.path()+"VIII.png", ResourceFile::Type::BitmapFont) ) );
  ASSERT_TRUE( fonts_.append_resource( ResourceFile("VIII_small", res_bitmap.path()+"VIII_small.png", ResourceFile::Type::BitmapFont) ) );

  // Should not exist
  ASSERT_FALSE( fonts_.append_resource( ResourceFile("IX", res_bitmap.path()+"IX.png", ResourceFile::Type::BitmapFont) ) );

  // Should already exist.
  ASSERT_FALSE( fonts_.append_resource( ResourceFile("VIII", res_bitmap.path()+"VIII.png", ResourceFile::Type::BitmapFont) ) );

  ResourceFile res;

  ASSERT_TRUE( res == ResourceFile::null );
  ASSERT_FALSE( res.exists() );

  res = fonts_.find_resource("LiberationSerif");
  ASSERT_TRUE( res.exists() );
  EXPECT_EQ( "LiberationSerif", res.name() );

  res = fonts_.find_resource("LiberationSerif-Bold");
  ASSERT_TRUE( res.exists() );
  EXPECT_EQ( "LiberationSerif-Bold", res.name() );

  res = fonts_.find_resource( "VIII" );
  ASSERT_TRUE( res.exists() );
  EXPECT_EQ( "VIII", res.name() );

  res = fonts_.find_resource( "VIII_small" );
  ASSERT_TRUE( res.exists() );
  EXPECT_EQ( "VIII_small", res.name() );

  // Should not exist
  res = fonts_.find_resource( "IX" );
  ASSERT_FALSE( res.exists() );
  EXPECT_EQ( "", res.name() );

  // NOTE: WindowsOS-specific error "unknown file : error : SEH exception with
  // code 0xc0000005 thrown in the test body." occurs here if the font cache
  // size does not match the expected value precisely.
  //
  // References:
  //
  // 1. https://www.assembla.com/spaces/OpenSurgSim/tickets/13#/activity/ticket:
  // 2. http://msdn.microsoft.com/library/vstudio/swezty51
  // 3. See also: tests/CMakeLists.txt FIXME note regarding err when using 'test'
  // target under Windows from the command line.
  EXPECT_EQ( 4, fonts_.size() );

  fonts_.clear();

  EXPECT_EQ( 0, fonts_.size() );
}

TEST_F( FontCacheTest, FontCacheAPI )
{
  Path p;
  File fp;
  nom::RenderWindow window;
  nom::FontCache cache;

  // We first need to ensure that the SDL2_ttf extension is initialized,
  // otherwise we will receive err messages upon trying to load TrueType fonts.
  nom::init_third_party(0);

  // Necessary for loading font resources
  ASSERT_TRUE( window.create( this->test_case(), 0, 0, SDL_WINDOW_HIDDEN ) == true )
  << "Could not create nom::RenderWindow object for loading font resources from";

  // cache.set_resource_handler( [&] (const ResourceFile& res, IFont* font) {
  //   nom::create_font(res, font);
  // });

  // Add two (2) bitmap fonts to the cache for testing use:
  ASSERT_TRUE( cache.append_resource( ResourceFile( "VIII", res_bitmap.path()+"VIII.png", ResourceFile::Type::BitmapFont ) ) )
  << "Could not insert BitmapFont resource VIII";

  ASSERT_TRUE( cache.append_resource( ResourceFile( "VIII_small", res_bitmap.path()+"VIII_small.png", ResourceFile::Type::BitmapFont ) ) )
  << "Could not insert BitmapFont resource VIII_small";

  // Add two (2) TrueType fonts to the cache for testing use:
  ASSERT_TRUE( cache.append_resource( ResourceFile( "LiberationSerif", res_truetype.path()+"LiberationSerif-Regular.ttf", ResourceFile::Type::TrueTypeFont ) ) )
  << "Could not insert TrueType resource LiberationSerif";

  ASSERT_TRUE( cache.append_resource( ResourceFile( "LiberationSerif-Bold", res_truetype.path()+"LiberationSerif-Bold.ttf", ResourceFile::Type::TrueTypeFont )  ) )
  << "Could not insert TrueType resource LiberationSerif-Bold";

  // Bitmap font tests:
  nom::Font bfont1 = *cache.load_resource( "VIII" );
  nom::Font bfont2 = *cache.load_resource( "VIII_small" );
  nom::Font bfont3 = *cache.load_resource( "VIII" );

  ASSERT_TRUE( bfont1->valid() )
  << "Font resource 1 should be valid";

  ASSERT_TRUE( bfont2->valid() )
  << "Font resource 2 should be valid";

  ASSERT_TRUE( bfont3->valid() )
  << "Font resource 3 should be valid";

  ASSERT_TRUE( bfont1 == bfont3 )
  << "Font resource 1 should be the same as font resource 3";

  nom::Text label1;
  nom::Text label2;
  label1.set_font( bfont1 );
  label2.set_font( bfont3->clone() );
  ASSERT_FALSE( label1.font() == label2.font() )
  << "bfont1 should **not** be the same as bfont3.";

  // TrueType font tests:
  nom::Font bfont4 = *cache.load_resource( "LiberationSerif" );
  nom::Font bfont5 = *cache.load_resource( "LiberationSerif" );

  ASSERT_TRUE( bfont4->valid() )
  << "Font resource 4 should be valid";

  ASSERT_TRUE( bfont5->valid() )
  << "Font resource 5 should be valid";

  ASSERT_TRUE( bfont4 == bfont5 )
  << "Font resource 4 should be the same as font resource 5";

  nom::Text label3;
  nom::Text label4;
  label3.set_font( bfont4 );
  label4.set_font( bfont5->clone() );
  ASSERT_FALSE( label3.font() == label4.font() )
  << "bfont4 should **not** be the same as bfont5";
}

} // namespace nom

int main( int argc, char** argv )
{
  ::testing::InitGoogleTest( &argc, argv );

  return RUN_ALL_TESTS();
}
